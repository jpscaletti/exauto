defmodule Auto.Repo do
  use Ecto.Repo, otp_app: :auto
end

defmodule Auto.Term do
  use Ecto.Schema
  import Ecto.Changeset
  alias Auto.Term

  schema "terms" do
    field(:parent_id, :integer)
    field(:text, :string)
    field(:length, :integer)
    timestamps()
  end

  def changeset(term, params \\ %{}) do
    term
    |> cast(params, [:parent_id, :text, :length, :id, :inserted_at, :updated_at])
    |> validate_required([:parent_id, :text, :length])
  end
end

defmodule Auto.Part do
  use Ecto.Schema
  import Ecto.Changeset
  alias Auto.Part

  schema "parts" do
    field(:parent_id, :integer)
    field(:prefix, :string)
    belongs_to(:term, Auto.Term)
    timestamps()
  end

  def changeset(part, params \\ %{}) do
    part
    |> cast(params, [:parent_id, :prefix, :term_id, :inserted_at, :updated_at])
    |> validate_required([:parent_id, :prefix, :term_id])
  end
end

defmodule Auto.Ecto do
  @min_length 2

  alias Auto.{Utils, Part, Term}

  def insert(parent_id, text, id \\ nil) do
    text = String.slice(text, 0..59)

    {:ok, term} =
      %Term{}
      |> Term.changeset(%{
        parent_id: parent_id,
        text: text,
        length: String.length(text),
        id: id
      })
      |> Auto.Repo.insert()

    text
    |> Utils.normalize()
    |> Utils.split()
    |> insert_parts(parent_id, term.id)
  end

  def insert_parts(words, parent_id, term_id) do
    parts = get_parts_data(words, parent_id, term_id, [])

    Ecto.Multi.new()
    |> Ecto.Multi.insert_all(:insert_all, Part, parts)
    |> Auto.Repo.transaction()
  end

  defp get_parts_data([], _parent_id, _term_id, acc), do: acc

  defp get_parts_data([word | rest], parent_id, term_id, acc) do
    now = NaiveDateTime.utc_now()

    acc =
      word
      |> Utils.slice_and_dice()
      |> Enum.filter(fn x -> String.length(x) >= @min_length end)
      |> Enum.map(fn prefix ->
        %{
          parent_id: parent_id,
          prefix: prefix,
          term_id: term_id,
          # not autogenerated when using insert_all/3
          inserted_at: now,
          updated_at: now
        }
      end)
      |> Enum.concat(acc)

    get_parts_data(rest, parent_id, term_id, acc)
  end

  # ---------------------------------------------------------------------------

  @doc """
  Delete a term form the database.
  """
  def delete(_parent_id, _text) do
  end

  # ---------------------------------------------------------------------------

  def match(parent_id, term) do
    terms = term |> Utils.normalize() |> Utils.split()

    case Enum.count(terms) do
      0 -> []
      _ -> match_terms(parent_id, terms)
    end
  end

  defp match_terms(parent_id, terms) do
    import Ecto.Query

    ids =
      from(
        p in Auto.Part,
        select: p.term_id,
        where: p.parent_id == ^parent_id,
        where: p.prefix in ^terms
      )
      |> Auto.Repo.all()

    from(t in Auto.Term, where: t.id in ^ids)
    |> Auto.Repo.all()
  end

  # ---------------------------------------------------------------------------

  def load_from_file(filename, parent_id) do
    filename
    |> File.stream!()
    |> Stream.each(fn x ->
      [id, text] = x |> String.trim() |> String.split(",")
      insert(parent_id, text, id)
    end)
    |> Stream.run()
  end
end
